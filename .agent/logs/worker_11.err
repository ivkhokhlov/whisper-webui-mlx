OpenAI Codex v0.87.0 (research preview)
--------
workdir: /Users/ivankhokhlov/code/mlx-ui/.
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: xhigh
reasoning summaries: auto
session id: 019be0a8-2e2b-7813-a8cc-91dd92314828
--------
user
# WORKER AGENT (3-phase harness)

You are the WORKER in a Planner→Worker→Judge pipeline.
Your job: execute `.agent/plan.md` as written, with minimal scope creep.

Non-interactive run (`codex exec`): do not ask questions. If unclear, make the smallest reasonable assumption and log it.

## Stop conditions
- If `.agent/STOP` exists: append “STOP seen” to `.agent/progress.md` and exit.
- If `.agent/DONE` exists: append “DONE seen” to `.agent/progress.md` and exit.

## Inputs you MUST read
- `.agent/PROJECT.md` (authoritative; includes TEST_CMD/LINT_CMD)
- `AGENTS.md` (repo rules)
- `docs/spec.md`
- `docs/dev.md` (if exists)
- `.agent/plan.md`
- `.agent/judge_feedback.md` (if present)
- `.agent/queue.md`
- `.agent/progress.md`
- `.agent/state.md`

## Core rules
- Implement ONLY the single task in `.agent/plan.md`.
- Do NOT mark tasks done in `.agent/queue.md` (Judge owns that).
- Prefer small, coherent changes. No big refactors unless the task explicitly requires it.
- All network-dependent logic must be best-effort with timeouts and exception handling.
- Bind server to localhost only.
- Queue must be strictly sequential: one job at a time; no parallel transcription runs.
- Never print secrets. If you need to log config, mask tokens.

## Logging
Ensure `.agent/logs/` exists.
Write/overwrite `.agent/worker_report.md` with:
- task id/title
- what changed (bullets)
- files changed (list)
- commands run + result (pass/fail)
- if failure: include a short excerpt of the error and what you think is next

Also append a WORKER entry to `.agent/progress.md` with:
- timestamp
- CODEX_ITERATION
- task id
- test + lint status summary

## Verification (must do)
Run TEST_CMD (from PROJECT.md). Capture output into a file.

Tip: to preserve exit codes with tee:
- use: `bash -lc "set -o pipefail; <TEST_CMD> 2>&1 | tee .agent/logs/test_${CODEX_ITERATION}.log"`

If LINT_CMD is set and command exists, run similarly and capture output:
- `.agent/logs/lint_${CODEX_ITERATION}.log`

If tests fail and you cannot fix quickly:
- write/update `.agent/BLOCKED.md` with exact errors + next steps
- exit (do not thrash)

## Output
Print a short summary:
- what you implemented
- test status
- pointers to worker_report + log files

mcp startup: no servers
exec
/bin/zsh -lc ls in /Users/ivankhokhlov/code/mlx-ui succeeded in 71ms:
AGENTS.md
Makefile
README.md
data
docs
mlx_ui
poetry.lock
pyproject.toml
scripts
tests

thinking
**Checking agent-related documentation**

I'm planning to read AGENTS.md and other related files to understand the role and setup of the .agent directory.
exec
/bin/zsh -lc 'ls -a' in /Users/ivankhokhlov/code/mlx-ui succeeded in 74ms:
.
..
.DS_Store
.agent
.git
.gitignore
.pytest_cache
.python-version
.ruff_cache
.venv
AGENTS.md
Makefile
README.md
data
docs
mlx_ui
poetry.lock
pyproject.toml
scripts
tests

thinking
**Checking STOP/DONE states**
exec
/bin/zsh -lc 'test -f .agent/STOP && echo STOP || true
test -f .agent/DONE && echo DONE || true' in /Users/ivankhokhlov/code/mlx-ui succeeded in 68ms:


thinking
**Listing needed project files for reading**
exec
/bin/zsh -lc 'cat AGENTS.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 61ms:
# AGENTS.md

This repo is developed using an autonomous loop (Planner → Worker → Judge) driven by `codex exec`.
Because each run starts with limited context, **durable state MUST be stored in `.agent/`**.

## Source of truth
- `.agent/PROJECT.md` — high-level constraints and commands
- `docs/spec.md` — product requirements
- `.agent/queue.md` — backlog (Judge marks tasks done)

## How to run
- Tests: `make test`
- Lint: `make lint`
- Format: `make fmt`
- Run server: `make run`

If Makefile does not exist yet, create it during bootstrap.

## Safety / security rules
- Never touch anything outside the repo root.

thinking
**Reviewing project documentation**

I'm examining the .agent/PROJECT.md file to gather any specific project context or guidelines that may inform the implementation approach.
exec
/bin/zsh -lc 'cat .agent/PROJECT.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 75ms:
# PROJECT (single source of truth for the harness)

PROJECT_NAME: "whisper-webui-mlx"
REPO_KIND: "new repo"

## Brief (1–2 paragraphs)
Build a **local macOS app for Apple Silicon (M1+)** that exposes a **Web UI on localhost** to manage **offline transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX). https://github.com/JosefAlbers/whisper-turbo-mlx

Turn the current console workflow (e.g. `wtm ... --any_lang=True`) into a tool that is easy to deploy on another M1+ Mac with **one command**, supports **batch uploads**, a **strictly sequential** processing queue (no parallelism), **job history + downloads**, optional **Telegram delivery of TXT results**, and (in the final phase) **live recording + chunked transcription**.

## Primary stack
Python 3.11+
- Backend/Web: FastAPI + Uvicorn
- Templates/UI: Jinja2 + minimal vanilla JS (no external CDNs; must work offline)
- Storage: SQLite (jobs metadata) + local filesystem (uploads/results/logs)
- Worker: a single sequential worker consuming a persistent queue
- Transcription: subprocess call to `wtm` with explicit language selection

## Commands (choose defaults if unknown)
TEST_CMD: "make test"

thinking
**Planning docs/spec.md creation**
exec
/bin/zsh -lc 'cat docs/spec.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 63ms:
# Spec — whisper-webui-mlx

## Goal
Create a **local-only** tool for **macOS Apple Silicon (M1+)** that provides a **Web UI on localhost** to manage **local transcription** of audio/video files using the engine from `whisper-turbo-mlx` via its CLI `wtm` (MLX).

The tool must be easy to deploy to another M1+ Mac (one command), and after the initial setup + model download it must work **fully offline**.

## MVP: Batch file transcription via Web UI
### UX
- User opens Web UI (localhost).
- User uploads **one or multiple files** (audio or video).
- User selects the **language manually** (no auto-detect).
- Files are placed into a **queue** and processed **strictly sequentially** (no parallel jobs).
- UI has:
  - Queue view: current job + pending jobs
  - History view: completed jobs + access to results

### Processing rules
- One worker processes one job at a time (sequential).
- Keep the ML model “warm” behavior in mind: avoid parallelism and avoid reinitialization churn.

thinking
**Checking for docs/dev.md**
exec
/bin/zsh -lc 'test -f docs/dev.md && cat docs/dev.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 60ms:
# Developer guide

## Requirements (target)
- macOS Apple Silicon (M1+)
- Python 3.11+
- Homebrew (for system deps like ffmpeg)

## Quick start (eventual)
```bash
./scripts/setup_and_run.sh
```
Notes:
- Requires Homebrew (for ffmpeg), Python 3.11+, and Poetry (the script installs missing deps via Homebrew).
- First run needs network access to install `whisper-turbo-mlx` and download the default model.
- Set `SKIP_MODEL_DOWNLOAD=1` to skip prefetching weights (not recommended).

## Manual dev loop
```bash
poetry install --with dev


thinking
**Reviewing agent plan file**
exec
/bin/zsh -lc 'cat .agent/plan.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 93ms:
# Plan

Task: WUI-040 — Telegram delivery
Acceptance: when env vars are set, send TXT + message; failures do not break pipeline; secrets masked

Assumptions:
- Telegram config is provided via environment variables and can be accessed from the worker process.
- Each completed job has a deterministic `.txt` result path to attach.

Implementation steps:
1) Inspect the worker completion flow to find where result paths are available and where to hook delivery.
2) Add a small config helper to read `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID`, plus a masking helper for logs.
3) Implement Telegram send helper with a short timeout; send a message plus the `.txt` file; catch and log failures without raising.
4) Call the helper after successful transcription; skip if config missing or `.txt` is absent; ensure pipeline continues.
5) Add tests with mocked HTTP calls to cover success, missing config (no call), and failure (no exception, masked logs).
6) Update docs to note the env vars if not already documented.

Files likely to touch:
- `mlx_ui/worker.py`
- `mlx_ui/transcriber.py` or `mlx_ui/app.py`

thinking
**Checking for judge feedback requirement**
exec
/bin/zsh -lc 'test -f .agent/judge_feedback.md && cat .agent/judge_feedback.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 80ms:
PASS

Notes:
- `make test` passed (rerun).
- `make lint` passed (rerun).
- Acceptance criteria met for WUI-030.

thinking
**Reviewing agent queue documentation**

I read the agent queue documentation to understand its design and current state, preparing to integrate or modify its functionality next.
exec
/bin/zsh -lc 'cat .agent/queue.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 58ms:
# Queue

## Now
- [ ] WUI-040 — Telegram delivery (acceptance: when env vars are set, send TXT + message; failures do not break pipeline; secrets masked)

## Next
- [ ] WUI-050 — Update check at startup (acceptance: if online, checks for updates with timeout; if offline, no errors and app works)

## Later
- [ ] WUI-090 — Live mode skeleton (acceptance: UI has “Live” page stub + technical plan in docs; no implementation yet)

## Done
- [x] WUI-030 — One-command setup & run on M1+ macOS (acceptance: `./scripts/setup_and_run.sh` installs deps, downloads models, starts server, and opens browser)
- [x] WUI-021 — Results browsing + download (acceptance: history page shows per-job links to view/download TXT and other generated formats)
- [x] WUI-020 — Integrate `wtm` CLI transcription (acceptance: for a job, system runs `wtm` with chosen language and produces at least `.txt` in `data/results/<job_id>/`)
- [x] WUI-012 — Sequential worker + fake transcriber (acceptance: single worker processes jobs strictly one-at-a-time; tests do not require ML model)
- [x] WUI-011 — Persistent job store (SQLite) (acceptance: jobs survive server restart; history page lists prior jobs)
- [x] WUI-010 — Upload endpoint + local storage (acceptance: user can upload multiple files; files saved under `data/uploads/` and jobs are created)
- [x] WUI-002 — Minimal WebUI shell (acceptance: localhost page renders with tabs: Queue + History, using server-side templates)
- [x] WUI-001A — Fix pytest availability for `make test` (acceptance: `make test` succeeds in a clean env by ensuring pytest is installed or Makefile uses Poetry/venv)

thinking
**Checking progress and state**
exec
/bin/zsh -lc 'cat .agent/progress.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 58ms:
# Progress Log (append-only)

- 2026-01-21T09:49:08 — INIT — Harness files created. Next: run the 3-phase loop.
- 2026-01-21T10:33:08Z — PLANNER — CODEX_ITERATION=1 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:37:23Z — WORKER — CODEX_ITERATION=1 — WUI-001 — tests: failed (pytest missing); lint: not run
- 2026-01-21T10:39:53Z — JUDGE — CODEX_ITERATION=1 — NEEDS_WORK — make test failed (pytest missing in venv); tests: failed (make test)
- 2026-01-21T10:42:24Z — PLANNER — CODEX_ITERATION=2 — selected WUI-001A (Fix pytest availability for `make test`). Queue updated (format fix for WUI-001A).
- 2026-01-21T10:49:11Z — WORKER — CODEX_ITERATION=2 — WUI-001A — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:52:47Z — JUDGE — CODEX_ITERATION=2 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T10:56:28Z — PLANNER — CODEX_ITERATION=3 — selected WUI-001 (Bootstrap repo skeleton). Queue unchanged.
- 2026-01-21T10:58:25Z — WORKER — CODEX_ITERATION=3 — WUI-001 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:01:51Z — JUDGE — CODEX_ITERATION=3 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:05:17Z — PLANNER — CODEX_ITERATION=4 — selected WUI-002 (Minimal WebUI shell). Queue unchanged.
- 2026-01-21T11:11:48Z — WORKER — CODEX_ITERATION=4 — WUI-002 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:16:13Z — JUDGE — CODEX_ITERATION=4 — PASS — acceptance met; tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:23:27Z — PLANNER — CODEX_ITERATION=5 — selected WUI-010 (Upload endpoint + local storage). Queue updated (moved WUI-010 to Now).
- 2026-01-21T11:33:16Z — WORKER — CODEX_ITERATION=5 — WUI-010 — tests: passed (make test); lint: passed (make lint)
- 2026-01-21T11:37:21Z — JUDGE — CODEX_ITERATION=5 — PASS — acceptance met; tests: passed (make test); lint: not rerun (worker reported pass)
- 2026-01-21T11:41:40Z — PLANNER — CODEX_ITERATION=6 — selected WUI-011 (Persistent job store (SQLite)). Queue updated (moved WUI-011 to Now).
- 2026-01-21T11:48:06Z — WORKER — CODEX_ITERATION=6 — WUI-011 — tests: passed (make test); lint: passed (make lint)

thinking
**Noting missing state**
exec
/bin/zsh -lc 'cat .agent/state.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 66ms:
last_task_id: WUI-030
last_verdict: PASS
consecutive_failures: 0

thinking
**Starting code inspection for worker**
exec
/bin/zsh -lc "rg --files -g '*.py' mlx_ui" in /Users/ivankhokhlov/code/mlx-ui succeeded in 114ms:
mlx_ui/app.py
mlx_ui/__init__.py
mlx_ui/transcriber.py
mlx_ui/db.py
mlx_ui/worker.py

thinking
**Starting core services**
exec
/bin/zsh -lc "sed -n '1,240p' mlx_ui/worker.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 65ms:
from __future__ import annotations

import logging
from pathlib import Path
import threading

from mlx_ui.db import claim_next_job, update_job_status
from mlx_ui.transcriber import Transcriber, WtmTranscriber

logger = logging.getLogger(__name__)

_worker_lock = threading.Lock()
_worker_instance: Worker | None = None


class Worker:
    def __init__(
        self,
        db_path: Path,
        results_dir: Path,
exec
/bin/zsh -lc "sed -n '1,260p' mlx_ui/transcriber.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 83ms:
import logging
import os
from pathlib import Path
import subprocess
from typing import Protocol

from mlx_ui.db import JobRecord

logger = logging.getLogger(__name__)


class Transcriber(Protocol):
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        raise NotImplementedError


class FakeTranscriber:
    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        results_dir = Path(results_dir)
        job_dir = results_dir / job.id

thinking
**Identifying job record definition**
exec
/bin/zsh -lc "sed -n '1,260p' mlx_ui/db.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 76ms:
from dataclasses import dataclass
from pathlib import Path
import sqlite3


@dataclass
class JobRecord:
    id: str
    filename: str
    status: str
    created_at: str
    upload_path: str


SCHEMA = """
CREATE TABLE IF NOT EXISTS jobs (
    id TEXT PRIMARY KEY,
    filename TEXT NOT NULL,
    status TEXT NOT NULL,
    created_at TEXT NOT NULL,

thinking
**Considering app component for routes**
exec
/bin/zsh -lc "sed -n '1,260p' mlx_ui/app.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 87ms:
from datetime import datetime, timezone
from pathlib import Path
import shutil
from uuid import uuid4

from fastapi import FastAPI, File, HTTPException, Request, UploadFile
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.templating import Jinja2Templates

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker

app = FastAPI(title="Whisper WebUI (MLX)")
templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent / "templates"))
BASE_DIR = Path(__file__).resolve().parent.parent
DEFAULT_UPLOADS_DIR = BASE_DIR / "data" / "uploads"
DEFAULT_RESULTS_DIR = BASE_DIR / "data" / "results"
DEFAULT_DB_PATH = BASE_DIR / "data" / "jobs.db"
app.state.uploads_dir = DEFAULT_UPLOADS_DIR
app.state.results_dir = DEFAULT_RESULTS_DIR

thinking
**Planning telegram config and send**

I'm preparing to add configuration and implement sending logic to meet acceptance criteria, ensuring failures don't break the pipeline and secrets are masked; next, I'll review existing tests.
exec
/bin/zsh -lc 'ls tests' in /Users/ivankhokhlov/code/mlx-ui succeeded in 80ms:
__init__.py
__pycache__
test_app.py
test_transcriber.py
test_worker.py

thinking
**Opening test file**
exec
/bin/zsh -lc "sed -n '1,260p' tests/test_worker.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 67ms:
from datetime import datetime, timedelta, timezone
from pathlib import Path
import threading
import time

from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs
from mlx_ui.worker import start_worker, stop_worker


class RecordingTranscriber:
    def __init__(self) -> None:
        self._lock = threading.Lock()
        self._active = False
        self.concurrent_detected = False
        self.seen: list[str] = []

    def transcribe(self, job: JobRecord, results_dir: Path) -> Path:
        with self._lock:
            if self._active:
                self.concurrent_detected = True

thinking
**Checking for test instructions**

I’m verifying if any existing tests provide guidance since there are no telegram tests found.
exec
/bin/zsh -lc "sed -n '1,260p' tests/test_transcriber.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 65ms:
from datetime import datetime, timezone
from pathlib import Path
import subprocess

from mlx_ui.db import JobRecord
from mlx_ui.transcriber import WtmTranscriber


def _make_job(tmp_path: Path) -> JobRecord:
    uploads_dir = tmp_path / "uploads" / "job1"
    uploads_dir.mkdir(parents=True, exist_ok=True)
    upload_path = uploads_dir / "sample.wav"
    upload_path.write_text("data", encoding="utf-8")
    return JobRecord(
        id="job1",
        filename="sample.wav",
        status="queued",
        created_at=datetime(2024, 1, 1, tzinfo=timezone.utc).isoformat(timespec="seconds"),
        upload_path=str(upload_path),
    )

thinking
**Checking test and docs patterns**

I'm verifying where Telegram-related tests are placed—likely in test_worker or a new file—and reviewing README and docs for environment variable mentions.
exec
/bin/zsh -lc "sed -n '1,260p' README.md" in /Users/ivankhokhlov/code/mlx-ui succeeded in 66ms:
# whisper-webui-mlx (agent harness bootstrap)

This repo currently contains the **3-phase Codex harness** (Planner → Worker → Judge) to build a local macOS (M1+) WebUI around `whisper-turbo-mlx` / `wtm`.

## One-command setup (macOS M1+)
```bash
./scripts/setup_and_run.sh
```
Notes: Homebrew is required; first run needs network access to install deps and download the model.

## Quick start (app)
Run the minimal FastAPI app on localhost:
```bash
make run
```

## Tests and lint
```bash
make test
make lint

thinking
**Planning documentation update and logging search**
exec
/bin/zsh -lc 'rg "logger" -n mlx_ui' in /Users/ivankhokhlov/code/mlx-ui succeeded in 69ms:
mlx_ui/transcriber.py:9:logger = logging.getLogger(__name__)
mlx_ui/transcriber.py:52:        logger.info("Running wtm for job %s", job.id)
mlx_ui/worker.py:10:logger = logging.getLogger(__name__)
mlx_ui/worker.py:64:            logger.exception("Worker failed to transcribe job %s", job.id)

thinking
**Planning Telegram helper module**

I'll create a new module for Telegram messaging with timeout and error handling, using the requests library if available per pyproject.
exec
/bin/zsh -lc "sed -n '1,200p' pyproject.toml" in /Users/ivankhokhlov/code/mlx-ui succeeded in 98ms:
[tool.poetry]
name = "mlx-ui"
version = "0.1.0"
description = ""
authors = ["Ivan Khokhlov <ivan.s.khokhlov@rt.ru>"]
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.115.6"
jinja2 = "^3.1.4"
uvicorn = "^0.32.1"
python-multipart = "^0.0.21"

[tool.poetry.group.dev.dependencies]
httpx = "^0.28.1"
pytest = "^8.3.4"
ruff = "^0.14.13"




thinking
**Choosing urllib with manual multipart**

Decided to implement Telegram messaging using only standard library urllib and related modules to avoid runtime dependencies, including a minimal multipart/form-data helper for sending files. Planning a new module with config dataclass, env reading, token masking, and message sending via urllib POST.
thinking
**Planning robust Telegram integration**

Planning to send transcription completion messages with optional file attachments using environment-configured tokens, ensuring best-effort delivery with short timeouts and masked token logging on failures. Integration will occur in the worker after transcription, with dedicated tests mocking network calls to verify success, failure, and config absence without raising errors.
exec
/bin/zsh -lc "sed -n '1,260p' tests/test_app.py" in /Users/ivankhokhlov/code/mlx-ui succeeded in 74ms:
from datetime import datetime, timezone
from pathlib import Path

from fastapi.testclient import TestClient

from mlx_ui.app import app
from mlx_ui.db import JobRecord, init_db, insert_job, list_jobs


def _configure_app(tmp_path: Path) -> None:
    app.state.uploads_dir = tmp_path / "uploads"
    app.state.results_dir = tmp_path / "results"
    app.state.db_path = tmp_path / "jobs.db"
    app.state.worker_enabled = False


def test_root_ok(tmp_path: Path) -> None:
    _configure_app(tmp_path)
    with TestClient(app) as client:
        response = client.get("/")

thinking
**Checking docs/tree.md presence**
exec
/bin/zsh -lc 'ls docs' in /Users/ivankhokhlov/code/mlx-ui succeeded in 89ms:
dev.md
spec.md
tree.md

thinking
**Reviewing docs/tree.md for updates**
exec
/bin/zsh -lc 'cat docs/tree.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 67ms:
# Project tree (curated)

This file is a human-maintained map of the repo. Update when structure changes.

## Current (bootstrap)
- `.agent/` — durable loop state + prompts
- `data/` — runtime uploads/results/logs/jobs.db (created on demand)
- `docs/` — spec + dev notes + this tree map
- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
- `mlx_ui/templates/` — Jinja2 templates
- `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
- `Makefile` — dev commands
- `pyproject.toml` — dependencies and tooling
- `README.md` — repo overview



thinking
**Designing Telegram helper with masking**

I'm drafting a telegram helper module that reads config from env, masks secrets for safe logging, and builds API URLs without exposing tokens; I'll add a masking utility and plan to update instructions and tests to avoid printing secrets.
thinking
**Implementing Telegram message and document sending with robust error handling**

I'm implementing functions to send Telegram messages and documents via multipart POST with proper masking of tokens in logs, ensuring failures log masked errors without raising, and designing tests for config presence, success, and failure scenarios including masked logging.
thinking
**Finalizing Telegram module design and integration plan**

I'm detailing the full telegram helper module with config reading, masked logging, multipart document upload, and robust error handling, plus planning worker integration and test coverage to ensure safe logging, offline testing, and no exceptions escape.
exec
/bin/zsh -lc 'cat mlx_ui/__init__.py' in /Users/ivankhokhlov/code/mlx-ui succeeded in 73ms:


thinking
**Adding new empty file placeholder**
file update
A /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/telegram.py
from dataclasses import dataclass
import logging
import mimetypes
import os
from pathlib import Path
import urllib.error
import urllib.parse
import urllib.request
import uuid

from mlx_ui.db import JobRecord

logger = logging.getLogger(__name__)

DEFAULT_TIMEOUT = 10.0


@dataclass(frozen=True)
class TelegramConfig:
    token: str
    chat_id: str


def read_telegram_config() -> TelegramConfig | None:
    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
    if not token or not chat_id:
        return None
    return TelegramConfig(token=token, chat_id=chat_id)


def mask_secret(value: str, visible: int = 4) -> str:
    if not value:
        return ""
    if len(value) <= visible:
        return "*" * len(value)
    return f"{'*' * (len(value) - visible)}{value[-visible:]}"


def maybe_send_telegram(
    job: JobRecord,
    result_path: Path,
    timeout: float = DEFAULT_TIMEOUT,
) -> None:
    config = read_telegram_config()
    if config is None:
        return

    result_path = Path(result_path)
    if not result_path.is_file():
        logger.warning(
            "Telegram delivery skipped for job %s: missing result %s",
            job.id,
            result_path,
        )
        return

    errors: list[tuple[str, Exception]] = []
    try:
        send_telegram_message(
            config,
            f"Transcription complete: {job.filename}",
            timeout=timeout,
        )
    except Exception as exc:
        errors.append(("message", exc))

    try:
        send_telegram_document(config, result_path, timeout=timeout)
    except Exception as exc:
        errors.append(("document", exc))

    if errors:
        masked_token = mask_secret(config.token)
        for kind, exc in errors:
            logger.warning(
                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
                kind,
                job.id,
                config.chat_id,
                masked_token,
                _describe_telegram_error(exc, config),
            )


def send_telegram_message(
    config: TelegramConfig,
    text: str,
    timeout: float = DEFAULT_TIMEOUT,
) -> None:
    payload = urllib.parse.urlencode(
        {"chat_id": config.chat_id, "text": text}
    ).encode("utf-8")
    request = urllib.request.Request(
        _api_url(config.token, "sendMessage"),
        data=payload,
        method="POST",
    )
    _perform_request(request, timeout)


def send_telegram_document(
    config: TelegramConfig,
    file_path: Path,
    caption: str | None = None,
    timeout: float = DEFAULT_TIMEOUT,
) -> None:
    file_path = Path(file_path)
    content_type = (
        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
    )
    fields: dict[str, str] = {"chat_id": config.chat_id}
    if caption:
        fields["caption"] = caption
    body, content_type_header = _encode_multipart(
        fields,
        {"document": (file_path.name, file_path.read_bytes(), content_type)},
    )
    request = urllib.request.Request(
        _api_url(config.token, "sendDocument"),
        data=body,
        method="POST",
        headers={
            "Content-Type": content_type_header,
            "Content-Length": str(len(body)),
        },
    )
    _perform_request(request, timeout)


def _perform_request(request: urllib.request.Request, timeout: float) -> None:
    with urllib.request.urlopen(request, timeout=timeout) as response:
        response.read()


def _encode_multipart(
    fields: dict[str, str],
    files: dict[str, tuple[str, bytes, str]],
) -> tuple[bytes, str]:
    boundary = uuid.uuid4().hex
    body_parts: list[bytes] = []
    for name, value in fields.items():
        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
        body_parts.append(
            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
        )
        body_parts.append(str(value).encode("utf-8"))
        body_parts.append(b"\r\n")
    for name, (filename, content, content_type) in files.items():
        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
        body_parts.append(
            (
                'Content-Disposition: form-data; name="'
                f'{name}"; filename="{filename}"\r\n'
            ).encode("utf-8")
        )
        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
        body_parts.append(content)
        body_parts.append(b"\r\n")
    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
    body = b"".join(body_parts)
    return body, f"multipart/form-data; boundary={boundary}"


def _api_url(token: str, method: str) -> str:
    return f"https://api.telegram.org/bot{token}/{method}"


def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
    if isinstance(exc, urllib.error.HTTPError):
        return f"HTTP {exc.code}"
    if isinstance(exc, urllib.error.URLError):
        reason = exc.reason
        reason_text = str(reason)
        return _mask_token(reason_text, config.token)
    return exc.__class__.__name__


def _mask_token(text: str, token: str) -> str:
    if not token or token not in text:
        return text
    return text.replace(token, mask_secret(token))
apply_patch(auto_approved=true) exited 0 in 20ms:
Success. Updated the following files:
A mlx_ui/telegram.py
file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))

file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))


thinking
**Integrating Telegram notification call**

I'm adding a call to the notification function in the worker after verifying text uses only ASCII; I'll apply the patch next.
file update
M /Users/ivankhokhlov/code/mlx-ui/./mlx_ui/worker.py
@@ -7,2 +7,3 @@
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
@@ -61,3 +62,3 @@
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
@@ -66,2 +67,6 @@
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
apply_patch(auto_approved=true) exited 0 in 23ms:
Success. Updated the following files:
M mlx_ui/worker.py
file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 

file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 



thinking
**Starting Telegram tests setup**

I'm drafting `tests/test_telegram.py` with pytest-style tests using plain functions and capturing logs via pytest features. I'm creating dummy response and job helper to simulate Telegram message sending for the first test case covering successful config and file scenario.
thinking
**Crafting comprehensive Telegram tests**

I'm finalizing tests for success, missing config, and failure with masked logs, ensuring env vars are monkeypatched and requests are faked properly. I'll add helpers for job and result file setup, import needed modules like logging and urllib.error, and capture warnings in logs to verify masked secrets. Next, I'll implement these tests fully and update docs accordingly.
file update
A /Users/ivankhokhlov/code/mlx-ui/./tests/test_telegram.py
import logging
from pathlib import Path
import urllib.error
import urllib.request

from mlx_ui.db import JobRecord
from mlx_ui.telegram import maybe_send_telegram, mask_secret


class DummyResponse:
    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
        self._status = status
        self._body = body or b"ok"

    def read(self) -> bytes:
        return self._body

    def getcode(self) -> int:
        return self._status

    def __enter__(self) -> "DummyResponse":
        return self

    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
        return False


def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
    uploads_dir = tmp_path / "uploads" / "job1"
    uploads_dir.mkdir(parents=True, exist_ok=True)
    upload_path = uploads_dir / "sample.wav"
    upload_path.write_text("data", encoding="utf-8")
    job = JobRecord(
        id="job1",
        filename="sample.wav",
        status="done",
        created_at="2024-01-01T00:00:00Z",
        upload_path=str(upload_path),
    )
    result_path = tmp_path / "results" / job.id
    result_path.mkdir(parents=True, exist_ok=True)
    txt_path = result_path / "sample.txt"
    txt_path.write_text("hello", encoding="utf-8")
    return job, txt_path


def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
    job, result_path = _make_job(tmp_path)
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")

    requests: list[tuple[urllib.request.Request, float]] = []

    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
        requests.append((request, float(timeout)))
        return DummyResponse()

    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)

    maybe_send_telegram(job, result_path, timeout=2.5)

    assert len(requests) == 2
    assert requests[0][1] == 2.5
    assert requests[1][1] == 2.5
    assert requests[0][0].full_url.endswith("/sendMessage")
    assert requests[1][0].full_url.endswith("/sendDocument")
    assert b"chat_id=123" in requests[0][0].data
    assert b"Transcription%20complete%3A" in requests[0][0].data
    assert b"chat_id" in requests[1][0].data
    assert result_path.name.encode("utf-8") in requests[1][0].data


def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
    job, result_path = _make_job(tmp_path)
    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)

    called = False

    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
        nonlocal called
        called = True
        return DummyResponse()

    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)

    maybe_send_telegram(job, result_path)

    assert called is False


def test_maybe_send_telegram_failure_logs_masked_token(
    monkeypatch, tmp_path: Path, caplog
) -> None:
    job, result_path = _make_job(tmp_path)
    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")

    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
        raise urllib.error.URLError("connection refused")

    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)

    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")

    maybe_send_telegram(job, result_path)

    assert "super-secret-token" not in caplog.text
    assert mask_secret("super-secret-token") in caplog.text
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
A tests/test_telegram.py
file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..82fd399675ecd6e1be5dc433381424167ed79ef4
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription%20complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text

file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..82fd399675ecd6e1be5dc433381424167ed79ef4
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription%20complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Improving test robustness for URL encoding**

Identified that URL-encoded spaces appear as `+` not `%20`, so adjusting test assertions to check for `b"Transcription+complete%3A"` instead of `%20` to avoid brittle failures in transcription-related tests.
file update
M /Users/ivankhokhlov/code/mlx-ui/./tests/test_telegram.py
@@ -67,3 +67,3 @@
     assert b"chat_id=123" in requests[0][0].data
-    assert b"Transcription%20complete%3A" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
     assert b"chat_id" in requests[1][0].data
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M tests/test_telegram.py
file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text

file update:
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Adding Telegram delivery docs**

I'm updating docs/dev.md to add a new section after Quick Start about optional Telegram delivery, specifying required env variables and noting failure handling and token masking.
file update
M /Users/ivankhokhlov/code/mlx-ui/./docs/dev.md
@@ -24,2 +24,9 @@
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M docs/dev.md
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Updating documentation to include new Telegram files**
file update
M /Users/ivankhokhlov/code/mlx-ui/./docs/tree.md
@@ -8,6 +8,6 @@
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M docs/tree.md
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text



thinking
**Reviewing test imports and lint setup**

I confirmed the use of `urllib.request.Request` in type annotations without explicit import is acceptable. There might be minor lint warnings from ruff about unused test arguments or naming, but no ruff config exists yet, so defaults apply. Next, I'll verify formatting and run lint checks to catch any issues.
thinking
**Checking Makefile for lint configuration**
exec
/bin/zsh -lc 'cat Makefile' in /Users/ivankhokhlov/code/mlx-ui succeeded in 84ms:
PYTHON ?= python
POETRY ?= poetry
POETRY_RUN ?= $(POETRY) run

.PHONY: test lint fmt run

test:
	$(POETRY_RUN) pytest

lint:
	$(POETRY_RUN) ruff check .

fmt:
	$(POETRY_RUN) ruff format .

run:
	$(POETRY_RUN) uvicorn mlx_ui.app:app --host 127.0.0.1 --port 8000
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text



thinking
**Reviewing Ruff default warnings and test imports**

Ruff defaults to selecting E and F codes, which matches the test imports usage without emitting unused import errors. Unused argument warnings are likely disabled, so no flags on unused `__exit__` args. Confirmed consistent type usage in dataclasses and environment-dependent Telegram call skips sending by default in tests.
thinking
**Verifying token masking and preparing test run**

Confirmed all logging masks the Telegram token and avoids leaking URLs or secrets, handling HTTPError and URLError safely. Planning to check CODEX_ITERATION env to run tests with tee logging per instructions.
exec
/bin/zsh -lc 'printenv CODEX_ITERATION' in /Users/ivankhokhlov/code/mlx-ui succeeded in 70ms:
11
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Ensuring log directory exists**

I'm adding logic to create the `.agent/logs/` directory if it doesn't exist, using `mkdir -p` to handle nested paths safely.
exec
/bin/zsh -lc 'mkdir -p .agent/logs' in /Users/ivankhokhlov/code/mlx-ui succeeded in 72ms:

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Running tests with tee**
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make test 2>&1 | tee .agent/logs/test_11.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 1.81s:
poetry run pytest
============================= test session starts ==============================
platform darwin -- Python 3.12.12, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/ivankhokhlov/code/mlx-ui
configfile: pyproject.toml
plugins: anyio-4.12.1
collected 9 items

tests/test_app.py ....                                                   [ 44%]
tests/test_telegram.py ...                                               [ 77%]
tests/test_transcriber.py .                                              [ 88%]
tests/test_worker.py .                                                   [100%]

=============================== warnings summary ===============================
mlx_ui/app.py:25
  /Users/ivankhokhlov/code/mlx-ui/mlx_ui/app.py:25: DeprecationWarning: 
          on_event is deprecated, use lifespan event handlers instead.
  
          Read more about it in the
          [FastAPI docs for Lifespan Events](https://fastapi.tiangolo.com/advanced/events/).
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Running lint check**

Tests passed, now running lint using the configured "make lint" command and saving output to a log file.
exec
/bin/zsh -lc 'bash -lc "set -o pipefail; make lint 2>&1 | tee .agent/logs/lint_11.log"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 684ms:
poetry run ruff check .
All checks passed!
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Preparing final report files**

I'm gathering the current UTC timestamp to include in the updated worker_report and progress files, listing task details, changed files, and test/lint results. Next, I'll write these comprehensive summaries to `.agent/worker_report.md` and append to `.agent/progress.md`.
exec
/bin/zsh -lc 'date -u "+%Y-%m-%dT%H:%M:%SZ"' in /Users/ivankhokhlov/code/mlx-ui succeeded in 92ms:
2026-01-21T13:11:11Z
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Creating worker report markdown**

I'm drafting a structured worker_report.md with task details, change summaries, affected files, and command outcomes, formatted in ASCII for clarity. Next, I'll write it to .agent/worker_report.md using a file write operation.
exec
/bin/zsh -lc "cat <<'EOF' > .agent/worker_report.md
# Worker Report

Task: WUI-040 — Telegram delivery

What changed:
- Added Telegram delivery helper with config parsing, masking, multipart send, and best-effort error handling.
- Hooked the worker completion path to send the message and transcript after successful jobs.
- Added Telegram delivery tests and documented env vars.

Files changed:
- mlx_ui/telegram.py
- mlx_ui/worker.py
- tests/test_telegram.py
- docs/dev.md
- docs/tree.md

Commands run + result:
- make test (pass)
- make lint (pass)
EOF" in /Users/ivankhokhlov/code/mlx-ui succeeded in 69ms:

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text


thinking
**Appending progress entry**

I'm adding a new line to `.agent/progress.md` recording successful tests and linting for iteration 11.
exec
/bin/zsh -lc 'echo "- 2026-01-21T13:11:11Z — WORKER — CODEX_ITERATION=11 — WUI-040 — tests: passed (make test); lint: passed (make lint)" >> .agent/progress.md' in /Users/ivankhokhlov/code/mlx-ui succeeded in 94ms:

file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text



thinking
**Preparing final report details**

I'm finalizing the output to explain the Telegram delivery helper added with urllib, noting it’s invoked post-transcription by the worker, accompanied by new tests and docs updates. Tests (`make test` and `make lint`) passed but issued FastAPI deprecation warnings, which I'll mention as a relevant note.
thinking
**Finalizing detailed implementation summary**

I'm preparing a clear explanation: added Telegram delivery using environment-configured tokens for post-job messages with masked logging, integrated in the worker after transcription, plus new tests and docs. The summary will list changed files and report test and lint success, note optional FastAPI deprecation warnings, and provide paths to the worker report and logs without extra commentary or questions.
codex
Implemented best‑effort Telegram delivery using env-configured bot token/chat ID, sending a completion message plus the `.txt` transcript after successful jobs with masked-token logging, and wired it into the worker completion flow. Added focused Telegram tests and documented the env vars, with the repo tree updated for the new module/tests.

Details:
- Added Telegram helpers and masking in `mlx_ui/telegram.py`, and invoked delivery after transcription in `mlx_ui/worker.py`.
- Added Telegram delivery tests in `tests/test_telegram.py` for success, missing config, and masked-log failures.
- Documented optional Telegram env vars in `docs/dev.md` and updated `docs/tree.md`.

Tests:
- `make test` (pass)
- `make lint` (pass)

Logs/report:
- `.agent/worker_report.md`
- `.agent/logs/test_11.log`
- `.agent/logs/lint_11.log`
file update:
diff --git a/docs/dev.md b/docs/dev.md
index 37100462d208054a56f35bbb33d69ae4146c083e..2d90cc01c5e94c77008a87189476a0dbb6a217d0
--- a/docs/dev.md
+++ b/docs/dev.md
@@ -22,6 +22,13 @@
 make run
 ```
 
+## Telegram delivery (optional)
+Set environment variables before starting the app:
+- `TELEGRAM_BOT_TOKEN`
+- `TELEGRAM_CHAT_ID`
+
+Failures are logged and do not break the job pipeline. Tokens are masked in logs.
+
 ## Notes
 - The app must bind only to `127.0.0.1`.
 - Keep network usage optional and best-effort (Telegram, update check).
diff --git a/docs/tree.md b/docs/tree.md
index 897a8daf1a065f3ee0767fd7392097597255d8bd..958a35c4cc32a984f0ef063c2ddd59b5f976404a
--- a/docs/tree.md
+++ b/docs/tree.md
@@ -6,10 +6,10 @@
 - `.agent/` — durable loop state + prompts
 - `data/` — runtime uploads/results/logs/jobs.db (created on demand)
 - `docs/` — spec + dev notes + this tree map
-- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`)
+- `mlx_ui/` — FastAPI app package (`app.py`, `db.py`, `worker.py`, `transcriber.py`, `telegram.py`)
 - `mlx_ui/templates/` — Jinja2 templates
 - `scripts/` — loop scripts + setup/run script (`setup_and_run.sh`)
-- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`)
+- `tests/` — pytest suite (`test_app.py`, `test_transcriber.py`, `test_worker.py`, `test_telegram.py`)
 - `Makefile` — dev commands
 - `pyproject.toml` — dependencies and tooling
 - `README.md` — repo overview
diff --git a/mlx_ui/telegram.py b/mlx_ui/telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..36a3041678e346bceb1c353a1f11cd48ac6a3f6c
--- /dev/null
+++ b/mlx_ui/telegram.py
@@ -0,0 +1,182 @@
+from dataclasses import dataclass
+import logging
+import mimetypes
+import os
+from pathlib import Path
+import urllib.error
+import urllib.parse
+import urllib.request
+import uuid
+
+from mlx_ui.db import JobRecord
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_TIMEOUT = 10.0
+
+
+@dataclass(frozen=True)
+class TelegramConfig:
+    token: str
+    chat_id: str
+
+
+def read_telegram_config() -> TelegramConfig | None:
+    token = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
+    chat_id = os.getenv("TELEGRAM_CHAT_ID", "").strip()
+    if not token or not chat_id:
+        return None
+    return TelegramConfig(token=token, chat_id=chat_id)
+
+
+def mask_secret(value: str, visible: int = 4) -> str:
+    if not value:
+        return ""
+    if len(value) <= visible:
+        return "*" * len(value)
+    return f"{'*' * (len(value) - visible)}{value[-visible:]}"
+
+
+def maybe_send_telegram(
+    job: JobRecord,
+    result_path: Path,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    config = read_telegram_config()
+    if config is None:
+        return
+
+    result_path = Path(result_path)
+    if not result_path.is_file():
+        logger.warning(
+            "Telegram delivery skipped for job %s: missing result %s",
+            job.id,
+            result_path,
+        )
+        return
+
+    errors: list[tuple[str, Exception]] = []
+    try:
+        send_telegram_message(
+            config,
+            f"Transcription complete: {job.filename}",
+            timeout=timeout,
+        )
+    except Exception as exc:
+        errors.append(("message", exc))
+
+    try:
+        send_telegram_document(config, result_path, timeout=timeout)
+    except Exception as exc:
+        errors.append(("document", exc))
+
+    if errors:
+        masked_token = mask_secret(config.token)
+        for kind, exc in errors:
+            logger.warning(
+                "Telegram %s delivery failed for job %s (chat_id=%s, token=%s): %s",
+                kind,
+                job.id,
+                config.chat_id,
+                masked_token,
+                _describe_telegram_error(exc, config),
+            )
+
+
+def send_telegram_message(
+    config: TelegramConfig,
+    text: str,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    payload = urllib.parse.urlencode(
+        {"chat_id": config.chat_id, "text": text}
+    ).encode("utf-8")
+    request = urllib.request.Request(
+        _api_url(config.token, "sendMessage"),
+        data=payload,
+        method="POST",
+    )
+    _perform_request(request, timeout)
+
+
+def send_telegram_document(
+    config: TelegramConfig,
+    file_path: Path,
+    caption: str | None = None,
+    timeout: float = DEFAULT_TIMEOUT,
+) -> None:
+    file_path = Path(file_path)
+    content_type = (
+        mimetypes.guess_type(file_path.name)[0] or "application/octet-stream"
+    )
+    fields: dict[str, str] = {"chat_id": config.chat_id}
+    if caption:
+        fields["caption"] = caption
+    body, content_type_header = _encode_multipart(
+        fields,
+        {"document": (file_path.name, file_path.read_bytes(), content_type)},
+    )
+    request = urllib.request.Request(
+        _api_url(config.token, "sendDocument"),
+        data=body,
+        method="POST",
+        headers={
+            "Content-Type": content_type_header,
+            "Content-Length": str(len(body)),
+        },
+    )
+    _perform_request(request, timeout)
+
+
+def _perform_request(request: urllib.request.Request, timeout: float) -> None:
+    with urllib.request.urlopen(request, timeout=timeout) as response:
+        response.read()
+
+
+def _encode_multipart(
+    fields: dict[str, str],
+    files: dict[str, tuple[str, bytes, str]],
+) -> tuple[bytes, str]:
+    boundary = uuid.uuid4().hex
+    body_parts: list[bytes] = []
+    for name, value in fields.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode("utf-8")
+        )
+        body_parts.append(str(value).encode("utf-8"))
+        body_parts.append(b"\r\n")
+    for name, (filename, content, content_type) in files.items():
+        body_parts.append(f"--{boundary}\r\n".encode("utf-8"))
+        body_parts.append(
+            (
+                'Content-Disposition: form-data; name="'
+                f'{name}"; filename="{filename}"\r\n'
+            ).encode("utf-8")
+        )
+        body_parts.append(f"Content-Type: {content_type}\r\n\r\n".encode("utf-8"))
+        body_parts.append(content)
+        body_parts.append(b"\r\n")
+    body_parts.append(f"--{boundary}--\r\n".encode("utf-8"))
+    body = b"".join(body_parts)
+    return body, f"multipart/form-data; boundary={boundary}"
+
+
+def _api_url(token: str, method: str) -> str:
+    return f"https://api.telegram.org/bot{token}/{method}"
+
+
+def _describe_telegram_error(exc: Exception, config: TelegramConfig) -> str:
+    if isinstance(exc, urllib.error.HTTPError):
+        return f"HTTP {exc.code}"
+    if isinstance(exc, urllib.error.URLError):
+        reason = exc.reason
+        reason_text = str(reason)
+        return _mask_token(reason_text, config.token)
+    return exc.__class__.__name__
+
+
+def _mask_token(text: str, token: str) -> str:
+    if not token or token not in text:
+        return text
+    return text.replace(token, mask_secret(token))
diff --git a/mlx_ui/worker.py b/mlx_ui/worker.py
index b7f1fe4b3f5a59bce91ad54ac13292c2a83ee5f7..4a759d0ed916e7f8d2f1b3bc7bfce417f4b68875
--- a/mlx_ui/worker.py
+++ b/mlx_ui/worker.py
@@ -5,6 +5,7 @@
 import threading
 
 from mlx_ui.db import claim_next_job, update_job_status
+from mlx_ui.telegram import maybe_send_telegram
 from mlx_ui.transcriber import Transcriber, WtmTranscriber
 
 logger = logging.getLogger(__name__)
@@ -59,11 +60,15 @@
         if job is None:
             return False
         try:
-            self.transcriber.transcribe(job, self.results_dir)
+            result_path = self.transcriber.transcribe(job, self.results_dir)
         except Exception:
             logger.exception("Worker failed to transcribe job %s", job.id)
             update_job_status(self.db_path, job.id, "failed")
             return True
+        try:
+            maybe_send_telegram(job, result_path)
+        except Exception:
+            logger.exception("Worker failed to deliver Telegram message for job %s", job.id)
         update_job_status(self.db_path, job.id, "done")
         return True
 
diff --git a/tests/test_telegram.py b/tests/test_telegram.py
new file mode 100644
index 0000000000000000000000000000000000000000..89dbde9d9de8b4e48f2b80363653958577c306a7
--- /dev/null
+++ b/tests/test_telegram.py
@@ -0,0 +1,109 @@
+import logging
+from pathlib import Path
+import urllib.error
+import urllib.request
+
+from mlx_ui.db import JobRecord
+from mlx_ui.telegram import maybe_send_telegram, mask_secret
+
+
+class DummyResponse:
+    def __init__(self, status: int = 200, body: bytes | None = None) -> None:
+        self._status = status
+        self._body = body or b"ok"
+
+    def read(self) -> bytes:
+        return self._body
+
+    def getcode(self) -> int:
+        return self._status
+
+    def __enter__(self) -> "DummyResponse":
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> bool:  # type: ignore[no-untyped-def]
+        return False
+
+
+def _make_job(tmp_path: Path) -> tuple[JobRecord, Path]:
+    uploads_dir = tmp_path / "uploads" / "job1"
+    uploads_dir.mkdir(parents=True, exist_ok=True)
+    upload_path = uploads_dir / "sample.wav"
+    upload_path.write_text("data", encoding="utf-8")
+    job = JobRecord(
+        id="job1",
+        filename="sample.wav",
+        status="done",
+        created_at="2024-01-01T00:00:00Z",
+        upload_path=str(upload_path),
+    )
+    result_path = tmp_path / "results" / job.id
+    result_path.mkdir(parents=True, exist_ok=True)
+    txt_path = result_path / "sample.txt"
+    txt_path.write_text("hello", encoding="utf-8")
+    return job, txt_path
+
+
+def test_maybe_send_telegram_success(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "token-12345")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    requests: list[tuple[urllib.request.Request, float]] = []
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        requests.append((request, float(timeout)))
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path, timeout=2.5)
+
+    assert len(requests) == 2
+    assert requests[0][1] == 2.5
+    assert requests[1][1] == 2.5
+    assert requests[0][0].full_url.endswith("/sendMessage")
+    assert requests[1][0].full_url.endswith("/sendDocument")
+    assert b"chat_id=123" in requests[0][0].data
+    assert b"Transcription+complete%3A" in requests[0][0].data
+    assert b"chat_id" in requests[1][0].data
+    assert result_path.name.encode("utf-8") in requests[1][0].data
+
+
+def test_maybe_send_telegram_skips_without_config(monkeypatch, tmp_path: Path) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.delenv("TELEGRAM_BOT_TOKEN", raising=False)
+    monkeypatch.delenv("TELEGRAM_CHAT_ID", raising=False)
+
+    called = False
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        nonlocal called
+        called = True
+        return DummyResponse()
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    maybe_send_telegram(job, result_path)
+
+    assert called is False
+
+
+def test_maybe_send_telegram_failure_logs_masked_token(
+    monkeypatch, tmp_path: Path, caplog
+) -> None:
+    job, result_path = _make_job(tmp_path)
+    monkeypatch.setenv("TELEGRAM_BOT_TOKEN", "super-secret-token")
+    monkeypatch.setenv("TELEGRAM_CHAT_ID", "123")
+
+    def fake_urlopen(request, timeout=0):  # type: ignore[no-untyped-def]
+        raise urllib.error.URLError("connection refused")
+
+    monkeypatch.setattr(urllib.request, "urlopen", fake_urlopen)
+
+    caplog.set_level(logging.WARNING, logger="mlx_ui.telegram")
+
+    maybe_send_telegram(job, result_path)
+
+    assert "super-secret-token" not in caplog.text
+    assert mask_secret("super-secret-token") in caplog.text

tokens used
63,765
